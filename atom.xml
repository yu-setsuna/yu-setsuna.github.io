<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeli&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yeli.io/"/>
  <updated>2020-06-16T14:31:45.076Z</updated>
  <id>https://blog.yeli.io/</id>
  
  <author>
    <name>叶离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1010 Radix</title>
    <link href="https://blog.yeli.io/algorithm/1010-Radix/"/>
    <id>https://blog.yeli.io/algorithm/1010-Radix/</id>
    <published>2020-06-16T13:34:00.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.</p><p>Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.</p><a id="more"></a><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure><p>Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个n进制的数，问另一个数是几进制时可以和它相等，如果不能相等，输出 impossible。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>令已知进制的数为n1，未知的为n2，循环判断n2在不同进制是否能和n1相等。</p><p>应注意的点：</p><ul><li><strong>输入字符范围是<code>0-z</code>不代表最高是36进制</strong>，正确的进制范围应该是n2中最大的数字+1 到 n2本身；</li><li><strong>使用二分查找节省时间</strong>；</li><li>n2的最大值是<code>zzzzzzzzzz</code>，按照36进制转换成10进制是<code>3656158440062975</code>，已经超过long，因此<strong>所有进制和结果的类型都至少为long long</strong>；</li><li>此时，<strong>使用二分查找中间值计算出的10进制数已经超过long long的范围，判断二分的条件时应该附加溢出判断</strong></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isdigit</span>(ch) ? ch - <span class="number">48</span> : ch - <span class="number">87</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">toDecimal</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">long</span> <span class="keyword">long</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = toInt(num[i]);</span><br><span class="line">        res += n * powl(radix, num.length() - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n1, n2;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span> t = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> target = toDecimal(n1, radix);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = toInt(*max_element(n2.begin(), n2.end())) + <span class="number">1</span>, r = max(l, target);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = l + (r - l) / <span class="number">2</span>, test = toDecimal(n2, mid);</span><br><span class="line">        <span class="keyword">if</span> (test == target) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (test &gt; target || test &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>解题时正数判断溢出可以直接用小于0。</strong></p><p>各种翻车，几乎摸清了20个测试点的作用。。。<br>第一遍没有想到进制超过36，<br>后改用二分，没有注意到转换出的值超过long long，<br>最后左边界忘记加1。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.liuchuo.net/archives/2458">柳婼 の blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目内容&quot;&gt;&lt;a href=&quot;#题目内容&quot; class=&quot;headerlink&quot; title=&quot;题目内容&quot;&gt;&lt;/a&gt;题目内容&lt;/h2&gt;&lt;p&gt;Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.&lt;/p&gt;
&lt;p&gt;Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/tags/algorithm/"/>
    
      <category term="pat" scheme="https://blog.yeli.io/tags/pat/"/>
    
      <category term="binary search" scheme="https://blog.yeli.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>1007 Maximum Subsequence Sum</title>
    <link href="https://blog.yeli.io/algorithm/1007-Maximum-Subsequence-Sum/"/>
    <id>https://blog.yeli.io/algorithm/1007-Maximum-Subsequence-Sum/</id>
    <published>2020-06-13T23:17:14.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><a id="more"></a><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求给出序列的最大子序列和。若结果不唯一，输出最前面的；若全为负值，输出0和整个范围；</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="法一-朴素算法"><a href="#法一-朴素算法" class="headerlink" title="法一 朴素算法"></a>法一 朴素算法</h3><p>直接用二重循环判断子序列的起始和结束位置，计算子序列和是否为最大；对子序列和计算的过程进行优化，使用 「前j个数的和 - 前i个数的和」 表示 「第i+1位到第j位的和」。</p><p>算法复杂度 O(N^2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN], acc[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> allnegative = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seq[i]);</span><br><span class="line">        <span class="keyword">if</span> (seq[i] &gt;= <span class="number">0</span>) allnegative = <span class="literal">false</span>;</span><br><span class="line">        acc[i] = acc[i - <span class="number">1</span>] + seq[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allnegative) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d"</span>, seq[<span class="number">1</span>], seq[n]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc[j] - acc[i - <span class="number">1</span>] &gt; maxv) &#123;</span><br><span class="line">                maxv = acc[j] - acc[i - <span class="number">1</span>];</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>, maxv, seq[start], seq[end]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法二-动态规划"><a href="#法二-动态规划" class="headerlink" title="法二 动态规划"></a>法二 动态规划</h3><p>由于最大的连续子序列的位置可能在序列的任何位置，「前i项最大子序列和」和 「前i-1项最大子序列和」是没有直接关系的。所以这里将问题改为 「先求以第i项为结尾的最大子序列和（从哪项开始没有限制），再取所有结果中的最大值」。</p><p>容易看出，求以第i项为结尾的最大子序列 可以根据第i-1项求出：<br>如果第i-1项结果为负，那么以第i项结果必然等于序列第i项的值（相当于去掉 负数+a 中的负数后，结果比原来大）；<br>否则等于前i-1项结果加序列第i项（相当于 非负数+a, 结果也会比a大）。</p><p>这样就可以得出递推关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以第i项为结尾的最大子序列和 &#x3D; max(以第i-1项为结尾的最大子序列和 + 序列第i项, 序列第i项)</span><br></pre></td></tr></table></figure><p>初始值「以第0项为结尾的最大子序列和」自然是等于0的。<br>此时，已经可以根据初始值和递推关系求出任意一项。再求出所有结果中最大的一项，即题目中要求的最大子序列和。</p><p>时间复杂度 O(N)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> allnegative = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seq[i]);</span><br><span class="line">        <span class="keyword">if</span> (seq[i] &gt;= <span class="number">0</span>) allnegative = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allnegative) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d"</span>, seq[<span class="number">1</span>], seq[n]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] &lt; <span class="number">0</span> ? seq[i] : sum[i - <span class="number">1</span>] + seq[i];</span><br><span class="line">        <span class="keyword">if</span> (sum[i - <span class="number">1</span>] &lt;= <span class="number">0</span>) t = i;</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; maxv) &#123;</span><br><span class="line">            maxv = sum[i];</span><br><span class="line">            start = t; end = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>, maxv, seq[start], seq[end]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168">1007</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目内容&quot;&gt;&lt;a href=&quot;#题目内容&quot; class=&quot;headerlink&quot; title=&quot;题目内容&quot;&gt;&lt;/a&gt;题目内容&lt;/h2&gt;&lt;p&gt;Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &amp;lt;= i &amp;lt;= j &amp;lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.&lt;/p&gt;
&lt;p&gt;Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/tags/algorithm/"/>
    
      <category term="pat" scheme="https://blog.yeli.io/tags/pat/"/>
    
      <category term="maximum subsequence sum" scheme="https://blog.yeli.io/tags/maximum-subsequence-sum/"/>
    
      <category term="dp" scheme="https://blog.yeli.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Generics in Java</title>
    <link href="https://blog.yeli.io/java/Generics-in-Java/"/>
    <id>https://blog.yeli.io/java/Generics-in-Java/</id>
    <published>2020-05-16T09:39:04.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<p><em>以下注释内容无法通过编译</em></p><h2 id="关于协变-（Covariant）"><a href="#关于协变-（Covariant）" class="headerlink" title="关于协变 （Covariant）"></a>关于协变 （Covariant）</h2><ul><li>Java 中数组协变的，泛型不是。</li><li>Java 1.5 开始子类覆盖父类的方法时可以返回具体的类型。</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">covarianceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组支持协变</span></span><br><span class="line">    Fruit[] fruits = <span class="keyword">new</span> Apple[]&#123; <span class="keyword">new</span> Apple() &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误，泛型不支持协变</span></span><br><span class="line">    <span class="comment">// ArrayList&lt;Fruit&gt; array = new ArrayList&lt;Apple&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用上界限定通配符</span></span><br><span class="line">    List&lt;? extends Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上界限定通配符（Upper-Bounds-Wildcards）"><a href="#上界限定通配符（Upper-Bounds-Wildcards）" class="headerlink" title="上界限定通配符（Upper Bounds Wildcards）"></a>上界限定通配符（Upper Bounds Wildcards）</h2><p>只能传入该类型及其子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extendTest</span><span class="params">(List&lt;? extends Fruit&gt; fruits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时容器不知道 List 的具体类型，（不能确定传入的是Fruit或Apple），因此为避免类型转换出错，也无法再向容器中添加任何类型</span></span><br><span class="line">    <span class="comment">// List&lt;?&gt; 同理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fruits.add(new Fruit());</span></span><br><span class="line">    <span class="comment">// fruits.add(new Apple());</span></span><br><span class="line">    <span class="comment">// fruits.add(new Food());</span></span><br><span class="line">    fruits.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下界限定通配符（Lower-Bounds-Wildcards）"><a href="#下界限定通配符（Lower-Bounds-Wildcards）" class="headerlink" title="下界限定通配符（Lower Bounds Wildcards）"></a>下界限定通配符（Lower Bounds Wildcards）</h2><p>只能传入该类型及其父类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">superTest</span><span class="params">(List&lt;? <span class="keyword">super</span> Fruit&gt; fruits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时容器已经可以确实传入的类型一定是Fruit或它的父类</span></span><br><span class="line">    <span class="comment">// 因此可以向容器中添加Fruit和它的子类对象，不会发生类型转换错误</span></span><br><span class="line">    fruits.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    fruits.add(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="comment">// fruits.add(new Food());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限定符测试"><a href="#限定符测试" class="headerlink" title="限定符测试"></a>限定符测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只能传入Fruit和它的父类</span></span><br><span class="line">    superTest(<span class="keyword">new</span> ArrayList&lt;Food&gt;());</span><br><span class="line">    <span class="comment">// superTest(new ArrayList&lt;Apple&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能传入Fruit和它的子类</span></span><br><span class="line">    extendTest(<span class="keyword">new</span> ArrayList&lt;Apple&gt;());</span><br><span class="line">    <span class="comment">// extendTest(new ArrayList&lt;Food&gt;());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归类型参数（Recursive-Type-Parameter）"><a href="#递归类型参数（Recursive-Type-Parameter）" class="headerlink" title="递归类型参数（Recursive Type Parameter）"></a>递归类型参数（Recursive Type Parameter）</h2><p>简化的栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ClassA</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span>&lt;<span class="title">ClassB</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassB <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Effective Java</em>中的建造者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Topping &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subclasses must override this method to return "this"</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subclass with hierarchical builder (Page 15)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归的类型参数和抽象的self方法一样，允许在子类中适当地进行方法链接，不需要转换类型。  </p><p><code>&lt;T extend builder&lt;T&gt;&gt;</code>和<code>&lt;T extend builder&gt;</code>这两者的区别：</p><blockquote><p>递归的 T extends Builder<T>是指，T 只能是 Builder 的子类型。因为 Builder是个泛型类，在描述「某个具体的 Builder 类型」 时，就必须带上类型参数。对于这里来说，就是 T。T extends Builder 严格来说是错误的。<br>当然，对于 Java 来讲，你不带 T 也是完全没问题的，编译器也不会给你警告，最多让 IDEA 提示一句「Raw use of parameterized class」，毕竟 Java 的泛型编译后都会被擦除，运行是时候都是一样的。不过，带上泛型更有利于编译器检查，也更有利于写出类型安全的代码。</p></blockquote><p>Pizza的构造器参数为<code>Builder&lt;?&gt; builder</code>，这里泛型定义为&lt;? extend Builder&gt;不应该更好吗？</p><blockquote><p>因为 Builder 声明为 T extends Builder<T> 就保证了 T 一定是 Builder 的子类型， 这里就没有必要再重复限制一次了。</p></blockquote><p>父类的Builder使用递归泛型及使用<code>self()</code>是为了 父类方法返回子类 这种功能吗？</p><blockquote><p>Self 类型是在接口中用描述实现接口的具体类型的特殊类型标识，用来安全地从父类型向子类型转换对象。一般来说，把父类型的对象转换为子类型的对象，都要用强制类型转换。这样做很不优雅，也不「type safe」。不过利用递归的类型参数，可以避免强制类型转换，这也是递归类型参数的重要用法。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/390135686">知乎：Java泛型递归模式的意义</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;以下注释内容无法通过编译&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于协变-（Covariant）&quot;&gt;&lt;a href=&quot;#关于协变-（Covariant）&quot; class=&quot;headerlink&quot; title=&quot;关于协变 （Covariant）&quot;&gt;&lt;/a&gt;关于协变 （Covariant）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java 中数组协变的，泛型不是。&lt;/li&gt;
&lt;li&gt;Java 1.5 开始子类覆盖父类的方法时可以返回具体的类型。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.yeli.io/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.yeli.io/tags/java/"/>
    
      <category term="generic" scheme="https://blog.yeli.io/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra&#39;s algorithm</title>
    <link href="https://blog.yeli.io/algorithm/Dijkstra-s-algorithm/"/>
    <id>https://blog.yeli.io/algorithm/Dijkstra-s-algorithm/</id>
    <published>2020-04-28T12:16:41.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<div class="notification is-info"><p>If 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself “Dijkstra would not have liked this.”, well, that would be enough immortality for me.    — E.W.Dijkstra<br>如果十年以后，你以快而脏的方式做什么事的时候，能想象我在你的肩后看着，然后对自己说：「Dijkstra 不会希望这样的。」那么对我来说，这就和永生一样了。</p></div><hr><p>适用于单源点最短路径，通常不能计算负权。时间复杂度O(n^2)。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>定义两个集合P、Q，表示已求出和未求出最短路径的顶点集；<br>从源点s出发，找到距离最近的点a直接放入P，显然s-&gt;a就是该点到源点的最短路径；<br>遍历集合Q中的点，将其命名为b，通过a-&gt;s-&gt;b缩短ab的距离，即判断as+sb是否小于ab（此过程名为“松弛”），<br>在Q中找到距离源点第二近的点，此时这个点已经进行过“松弛”，故该点到源点的距离也是最短，<br>然后重复以上过程，即可得到源点到其它所有点的最短路径。</p><a id="more"></a><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>若存在点权，应特别注意源点s。因为在第一步中直接将s添加到P，松弛过程中不会再计算s的点权</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认源点为s，图为e</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dis[i] = e[s][i];</span><br><span class="line">&#125;</span><br><span class="line">p[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    min = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[j] &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">            min = dis[j];</span><br><span class="line">            u = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[v] &amp;&amp; e[u][v] != INF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[u][v]) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;notification is-info&quot;&gt;
&lt;p&gt;If 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself “Dijkstra would not have liked this.”, well, that would be enough immortality for me.    — E.W.Dijkstra&lt;br&gt;如果十年以后，你以快而脏的方式做什么事的时候，能想象我在你的肩后看着，然后对自己说：「Dijkstra 不会希望这样的。」那么对我来说，这就和永生一样了。&lt;/p&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;适用于单源点最短路径，通常不能计算负权。时间复杂度O(n^2)。&lt;/p&gt;
&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;定义两个集合P、Q，表示已求出和未求出最短路径的顶点集；&lt;br&gt;从源点s出发，找到距离最近的点a直接放入P，显然s-&amp;gt;a就是该点到源点的最短路径；&lt;br&gt;遍历集合Q中的点，将其命名为b，通过a-&amp;gt;s-&amp;gt;b缩短ab的距离，即判断as+sb是否小于ab（此过程名为“松弛”），&lt;br&gt;在Q中找到距离源点第二近的点，此时这个点已经进行过“松弛”，故该点到源点的距离也是最短，&lt;br&gt;然后重复以上过程，即可得到源点到其它所有点的最短路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/tags/algorithm/"/>
    
      <category term="shortest path" scheme="https://blog.yeli.io/tags/shortest-path/"/>
    
  </entry>
  
  <entry>
    <title>Manacher&#39;s algorithm</title>
    <link href="https://blog.yeli.io/algorithm/Manacher-s-algorithm/"/>
    <id>https://blog.yeli.io/algorithm/Manacher-s-algorithm/</id>
    <published>2020-04-25T10:40:48.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<p>求字符串的最长回文子串，线性时间复杂度。</p><p>传统思路为遍历每个字符，以该字符为中心向两边查找，时间复杂度为O(n^2)，<br>Manachar算法充分利用回文的特点（对称性），减少对回文中心右侧的重复判断，可提升时间复杂度为O(n)。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>由于回文分为偶回文和奇回文，为处理简便，将其全部转换为奇回文。<br>e.g. <code>abbc</code> 转换为 <code>^a#b#b#c$</code></p><h3 id="定义数组int-p-i-，表示以i为中心的最长回文半径"><a href="#定义数组int-p-i-，表示以i为中心的最长回文半径" class="headerlink" title="定义数组int p[i]，表示以i为中心的最长回文半径"></a>定义数组<code>int p[i]</code>，表示以i为中心的最长回文半径</h3><p>e.g.<br><img src="/images/Snipaste_2020-04-25_19-53-30.png" alt="数组p"></p><h3 id="维护回文中心和回文右边界"><a href="#维护回文中心和回文右边界" class="headerlink" title="维护回文中心和回文右边界"></a>维护回文中心和回文右边界</h3><p>在此基础上对字符串进行遍历，若字符在右边界内，则可以利用对称性加快查找。</p><p>此时应注意，<strong>对称位置上的最长回文半径长度可能超过当前字符到边界的距离</strong>，所以p[i]应为<code>min(p[mirror_i], mx - i)</code>。</p><p>若当前字符已经在边界外，可暂时将p[i]赋为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; boundary) &#123;</span><br><span class="line">    p[i] = min(p[mirror_i], mx - i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    p[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新p-i"><a href="#更新p-i" class="headerlink" title="更新p[i]"></a>更新p[i]</h3><p>以i为中心向两边扩展，更新p</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (str[i - p[i]] == str[i + p[i]]) &#123;</span><br><span class="line">    p[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// makes all palindromes odd by inserting #</span></span><br><span class="line">    <span class="built_in">string</span> converted = <span class="string">"^#"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        converted += s[i];</span><br><span class="line">        converted += <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    converted += <span class="string">"$"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mcenter = <span class="number">0</span>, mlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> center = <span class="number">0</span>, boundary = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[converted.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; converted.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// update by the mirror data</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; boundary) p[i] = min(p[<span class="number">2</span> * center - i], boundary - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// then extend using naive method</span></span><br><span class="line">        <span class="keyword">while</span> (converted[i - p[i]] == converted[i + p[i]]) p[i]++;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// update the palindrome cneter</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; boundary) &#123;</span><br><span class="line">            center = i;</span><br><span class="line">            boundary = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maintain the max center and the max length</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] - <span class="number">1</span> &gt; mlength) &#123;</span><br><span class="line">            mcenter = i;</span><br><span class="line">            mlength = p[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr((mcenter - mlength) / <span class="number">2</span>, mlength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ethsonliu.com/2018/04/manacher.html">https://ethsonliu.com/2018/04/manacher.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求字符串的最长回文子串，线性时间复杂度。&lt;/p&gt;
&lt;p&gt;传统思路为遍历每个字符，以该字符为中心向两边查找，时间复杂度为O(n^2)，&lt;br&gt;Manachar算法充分利用回文的特点（对称性），减少对回文中心右侧的重复判断，可提升时间复杂度为O(n)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/tags/algorithm/"/>
    
      <category term="longest palindromic substring" scheme="https://blog.yeli.io/tags/longest-palindromic-substring/"/>
    
  </entry>
  
  <entry>
    <title>Floyd-Warshall algorithm</title>
    <link href="https://blog.yeli.io/algorithm/Floyd-Warshall-algorithm/"/>
    <id>https://blog.yeli.io/algorithm/Floyd-Warshall-algorithm/</id>
    <published>2020-04-25T09:33:27.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<p>适用于多源最短路径，也被用于计算有有向图的传递闭包，可以正确处理有向图和负权，时间复杂度O(n^3)、空间复杂度O(n^2)。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>在两个点AB之找到第三个点C，使 <code>AC + CB &lt; AB</code></p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">            path[i][j] = min(path[i][j], path[i][k] + path[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适用于多源最短路径，也被用于计算有有向图的传递闭包，可以正确处理有向图和负权，时间复杂度O(n^3)、空间复杂度O(n^2)。&lt;/p&gt;
&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;在两个点AB之找到第三个点C，使 &lt;code&gt;AC + CB &amp;lt; AB&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.yeli.io/tags/algorithm/"/>
    
      <category term="shortest path" scheme="https://blog.yeli.io/tags/shortest-path/"/>
    
  </entry>
  
  <entry>
    <title>Serializable</title>
    <link href="https://blog.yeli.io/java/Serializable/"/>
    <id>https://blog.yeli.io/java/Serializable/</id>
    <published>2019-12-02T06:04:24.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Java 中使用 Serializable 接口进行序列化。<br>Serializable 只是语义接口，无实际方法 </p><h2 id="SerialVersionUID"><a href="#SerialVersionUID" class="headerlink" title="SerialVersionUID"></a>SerialVersionUID</h2><p>Java 反序列化时通过判断字节流和相应实体类的 sesrialVersionUID 验证版本是否一致，一致时才能进行反序列化，否则抛出 InvalidCastException </p><a id="more"></a><h3 id="显式定义"><a href="#显式定义" class="headerlink" title="显式定义"></a>显式定义</h3><p>SerialVersionUID 的两种显式生成方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类名、接口名、成员方法、属性生成的 64 位哈希 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">long</span>   serialVersionUID = xxxxL;</span><br></pre></td></tr></table></figure><h3 id="隐式定义"><a href="#隐式定义" class="headerlink" title="隐式定义"></a>隐式定义</h3><p>当一个类实现 Serializable 接口但没有定义 serialVersionUID 时，Java 序列化机制会根据编译的 Class 自动生成一个 serialVersionUID，此时如文件中没有发生变化，则 serialVersionUID 也不会发生变化 </p><h3 id="阿里巴巴-Java-开发手册中对-serialVersionUID-的规定"><a href="#阿里巴巴-Java-开发手册中对-serialVersionUID-的规定" class="headerlink" title="阿里巴巴 Java 开发手册中对 serialVersionUID 的规定"></a>阿里巴巴 Java 开发手册中对 serialVersionUID 的规定</h3><blockquote><p>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。  </p></blockquote><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>Java 在进行序列化时只保存对象的状态，不会保存静态变量，但是 serialVersionUID 会被写入到序列化文件中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectStreamClass.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">this</span>.writeNull(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">int</span> handle; </span><br><span class="line">        <span class="keyword">if</span> (!unshared &amp;&amp; (handle = <span class="keyword">this</span>.handles.lookup(desc)) != -<span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">this</span>.writeHandle(handle); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123; </span><br><span class="line">            <span class="keyword">this</span>.writeProxyDesc(desc, unshared); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.writeNonProxyDesc(desc, unshared); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    out.writeUTF(<span class="keyword">this</span>.name); </span><br><span class="line">    out.writeLong(<span class="keyword">this</span>.getSerialVersionUID()); </span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>Java 对象中使用 Serializable 接口进行序列化，类中不需要进行序列化的字段可以使用 trainsient 修饰 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h2&gt;&lt;p&gt;Java 中使用 Serializable 接口进行序列化。&lt;br&gt;Serializable 只是语义接口，无实际方法 &lt;/p&gt;
&lt;h2 id=&quot;SerialVersionUID&quot;&gt;&lt;a href=&quot;#SerialVersionUID&quot; class=&quot;headerlink&quot; title=&quot;SerialVersionUID&quot;&gt;&lt;/a&gt;SerialVersionUID&lt;/h2&gt;&lt;p&gt;Java 反序列化时通过判断字节流和相应实体类的 sesrialVersionUID 验证版本是否一致，一致时才能进行反序列化，否则抛出 InvalidCastException &lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.yeli.io/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.yeli.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CSRF</title>
    <link href="https://blog.yeli.io/web/CSRF/"/>
    <id>https://blog.yeli.io/web/CSRF/</id>
    <published>2019-11-26T06:19:44.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 </p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><ol start="0"><li><p>受害者登录a.com，并保留了登录凭证（Cookie）。 </p></li><li><p>攻击者引诱受害者访问了b.com。 </p></li><li><p>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会… </p></li><li><p>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 </p></li><li><p>a.com以受害者的名义执行了act=xx。 </p></li><li><p>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 </p></li></ol><p>CSRF攻击是以用户身份发送恶意请求（到受信网站），用于发送邮件、购买商品、转账等。 </p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer.php?toBankId</span>=<span class="string">11&amp;money</span>=<span class="string">1000</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.mybank.com/Transfer"</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"xiaoming"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"for"</span> <span class="attr">value</span>=<span class="string">"hacker"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>在Csrf攻击中Get请求比Post请求更容易，应严格遵守HTTP规范，使用Post或Put更新请求资源。 </p><p>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的 </p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>可从服务器端和客户端两方面进行，在服务器端防御效果更好 </p><h3 id="1-Cookie-Hashing（双重Cookie认证）"><a href="#1-Cookie-Hashing（双重Cookie认证）" class="headerlink" title="1.Cookie Hashing（双重Cookie认证）"></a>1.Cookie Hashing（双重Cookie认证）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">　　　　$hash = md5($_COOKIE[<span class="string">'cookie'</span>]); </span><br><span class="line">　　<span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line">　　&lt;form method=”POST” action=”transfer.php”&gt; </span><br><span class="line">　　　　&lt;input type=”text” name=”toBankId”&gt; </span><br><span class="line">　　　　&lt;input type=”text” name=”money”&gt; </span><br><span class="line">　　　　&lt;input type=”hidden” name=”hash” value=”<span class="meta">&lt;?</span>=$hash;<span class="meta">?&gt;</span>”&gt; </span><br><span class="line">　　　　&lt;input type=”submit” name=”submit” value=”Submit”&gt; </span><br><span class="line">　　&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>由于网站无法获取第三方Cookie，因此这个方案可以杜绝大部分Csrf攻击。 </p><p>但任何跨域请求都会导致前端无法获取Cookie中的字段（包括子域名之间），于是：</p><p>如果用户访问的网站为<code>www.a.com</code>，而后端的api域名为<code>api.a.com</code>。那么在<code>www.a.com</code>下，前端拿不到<code>api.a.com</code>的Cookie，也就无法完成双重Cookie认证。 </p><p>于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 </p><p>任何一个子域都可以修改a.com下的Cookie。 </p><p>某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 </p><p>攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向<code>www.a.com</code>下，发起CSRF攻击。 </p><h3 id="2-CSRF-TOKEN"><a href="#2-CSRF-TOKEN" class="headerlink" title="2.CSRF TOKEN"></a>2.CSRF TOKEN</h3><p>用户打开页面时，服务器给该用户生成一个Token，并保存在Session中，页面加载时将Token插入<code>&lt;a/&gt;&lt;form/&gt;</code>，如 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器对Token进行验证 </p><p>但分布式网站中，使用Session存储CSRF Token还需要Redis等进行。在读取和验证CSRF Token时会可能引起较大的性能问题， </p><p>可采用Encrypted Token Pattern方式的计算结果代替随机字符串，这样可以避免读取Token </p><blockquote><p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。<br>来自 <a href="https://juejin.im/post/5bc009996fb9a05d0a055192">https://juejin.im/post/5bc009996fb9a05d0a055192</a></p></blockquote><h3 id="3-Samesite-Cookie属性"><a href="#3-Samesite-Cookie属性" class="headerlink" title="3.Samesite Cookie属性"></a>3.Samesite Cookie属性</h3><p>在Set-Cookie中加入属性Samesite，如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo&#x3D;1; Samesite&#x3D;Strict</span><br></pre></td></tr></table></figure><p>表明在任何情况下第三方网站发送请求时都不携带该Cookie </p><p>但目前兼容性较差，且不支持子域 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 &lt;/p&gt;
&lt;h2 id=&quot;完整流程&quot;&gt;&lt;a href=&quot;#完整流程&quot; class=&quot;headerlink&quot; title=&quot;完整流程&quot;&gt;&lt;/a&gt;完整流程&lt;/h2&gt;&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;&lt;p&gt;受害者登录a.com，并保留了登录凭证（Cookie）。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;攻击者引诱受害者访问了b.com。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会… &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.com以受害者的名义执行了act=xx。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CSRF攻击是以用户身份发送恶意请求（到受信网站），用于发送邮件、购买商品、转账等。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://blog.yeli.io/categories/web/"/>
    
    
      <category term="web" scheme="https://blog.yeli.io/tags/web/"/>
    
      <category term="csrf" scheme="https://blog.yeli.io/tags/csrf/"/>
    
  </entry>
  
  <entry>
    <title>Some tags in maven</title>
    <link href="https://blog.yeli.io/java/Some-tags-in-maven/"/>
    <id>https://blog.yeli.io/java/Some-tags-in-maven/</id>
    <published>2019-11-19T11:15:30.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven标签-lt-scope-gt-的作用"><a href="#Maven标签-lt-scope-gt-的作用" class="headerlink" title="Maven标签&lt;scope/&gt;的作用"></a>Maven标签<code>&lt;scope/&gt;</code>的作用</h2><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>默认值，即项目的整个编译、测试、运行阶段</p><h3 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h3><p>只作用于编译阶段、测试阶段，运行时使用容器或JDK中的jar包，例如，当使用Java EE构建一个web应用时，你会设置对Servlet API和相关的Java EE APIs的依赖范围为provided，因为web容器提供了运行时的依赖。 </p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>不作用在编译时，但会作用在运行和测试时 </p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>表明使用此依赖范围的依赖，只在编译测试代码和运行测试的时候需要，应用的正常运行不需要此类依赖。 </p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>只可在<code>&lt;dependcyManagent/&gt;</code>中使用，表示从其它的pom中导入dependency的配置  </p><blockquote><p>This scope is only supported on a dependency of type pom in the <code>&lt;dependencyManagement/&gt;</code> section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s <code>&lt;dependencyManagement/&gt;</code> section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.<br><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">https://maven.apache.org</a>  </p></blockquote><a id="more"></a><h2 id="Maven标签-lt-dependencies-gt-和-lt-dependencyManagement-gt-的区别"><a href="#Maven标签-lt-dependencies-gt-和-lt-dependencyManagement-gt-的区别" class="headerlink" title="Maven标签&lt;dependencies/&gt;和&lt;dependencyManagement/&gt;的区别"></a>Maven标签<code>&lt;dependencies/&gt;</code>和<code>&lt;dependencyManagement/&gt;</code>的区别</h2><p>Maven使用<code>&lt;dependencyManagement/&gt;</code>提供管理依赖版本的方式，通常用于pom顶层。<br>使用<code>&lt;dependencyManagement/&gt;</code> 元素能让子项目中引用一个依赖而不用显式的列出版本号。 </p><p>Maven 会向上找到一个拥有<code>&lt;dependencyManagement/&gt;</code> 元素的项目配置版本;<br><code>&lt;dependencyManagement/&gt;</code>里只声明依赖，但需要在子项目中进行引入。</p><h2 id="阿里巴巴-Java-开发手册中对-lt-dependencies-gt-的规定"><a href="#阿里巴巴-Java-开发手册中对-lt-dependencies-gt-的规定" class="headerlink" title="阿里巴巴 Java 开发手册中对 &lt;dependencies/&gt; 的规定"></a>阿里巴巴 Java 开发手册中对 <code>&lt;dependencies/&gt;</code> 的规定</h2><blockquote><p>【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在 语句块中。 说明：里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的 里的依赖都会自动引入，并默认被所有的子项目继承。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven标签-lt-scope-gt-的作用&quot;&gt;&lt;a href=&quot;#Maven标签-lt-scope-gt-的作用&quot; class=&quot;headerlink&quot; title=&quot;Maven标签&amp;lt;scope/&amp;gt;的作用&quot;&gt;&lt;/a&gt;Maven标签&lt;code&gt;&amp;lt;scope/&amp;gt;&lt;/code&gt;的作用&lt;/h2&gt;&lt;h3 id=&quot;compile&quot;&gt;&lt;a href=&quot;#compile&quot; class=&quot;headerlink&quot; title=&quot;compile&quot;&gt;&lt;/a&gt;compile&lt;/h3&gt;&lt;p&gt;默认值，即项目的整个编译、测试、运行阶段&lt;/p&gt;
&lt;h3 id=&quot;provide&quot;&gt;&lt;a href=&quot;#provide&quot; class=&quot;headerlink&quot; title=&quot;provide&quot;&gt;&lt;/a&gt;provide&lt;/h3&gt;&lt;p&gt;只作用于编译阶段、测试阶段，运行时使用容器或JDK中的jar包，例如，当使用Java EE构建一个web应用时，你会设置对Servlet API和相关的Java EE APIs的依赖范围为provided，因为web容器提供了运行时的依赖。 &lt;/p&gt;
&lt;h3 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h3&gt;&lt;p&gt;不作用在编译时，但会作用在运行和测试时 &lt;/p&gt;
&lt;h3 id=&quot;test&quot;&gt;&lt;a href=&quot;#test&quot; class=&quot;headerlink&quot; title=&quot;test&quot;&gt;&lt;/a&gt;test&lt;/h3&gt;&lt;p&gt;表明使用此依赖范围的依赖，只在编译测试代码和运行测试的时候需要，应用的正常运行不需要此类依赖。 &lt;/p&gt;
&lt;h3 id=&quot;import&quot;&gt;&lt;a href=&quot;#import&quot; class=&quot;headerlink&quot; title=&quot;import&quot;&gt;&lt;/a&gt;import&lt;/h3&gt;&lt;p&gt;只可在&lt;code&gt;&amp;lt;dependcyManagent/&amp;gt;&lt;/code&gt;中使用，表示从其它的pom中导入dependency的配置  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This scope is only supported on a dependency of type pom in the &lt;code&gt;&amp;lt;dependencyManagement/&amp;gt;&lt;/code&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s &lt;code&gt;&amp;lt;dependencyManagement/&amp;gt;&lt;/code&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.&lt;br&gt;&lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html&quot;&gt;https://maven.apache.org&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.yeli.io/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.yeli.io/tags/java/"/>
    
      <category term="maven" scheme="https://blog.yeli.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.yeli.io/unknown/Hello-World/"/>
    <id>https://blog.yeli.io/unknown/Hello-World/</id>
    <published>1969-12-31T16:00:00.000Z</published>
    <updated>2020-06-16T14:31:45.076Z</updated>
    
    <content type="html"><![CDATA[<p>This is a test page.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is a test page.&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
