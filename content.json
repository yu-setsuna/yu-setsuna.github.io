{"pages":[],"posts":[{"title":"CSRF","text":"介绍CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 完整流程 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会… a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 CSRF攻击是以用户身份发送恶意请求（到受信网站），用于发送邮件、购买商品、转账等。 例子Get请求1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; Post请求123456&lt;form action=\"http://www.mybank.com/Transfer\" method=POST&gt; &lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /&gt; &lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /&gt; &lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 思想在Csrf攻击中Get请求比Post请求更容易，应严格遵守HTTP规范，使用Post或Put更新请求资源。 CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的 防御可从服务器端和客户端两方面进行，在服务器端防御效果更好 1.Cookie Hashing（双重Cookie认证）12345678910&lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 由于网站无法获取第三方Cookie，因此这个方案可以杜绝大部分Csrf攻击。 但任何跨域请求都会导致前端无法获取Cookie中的字段（包括子域名之间），于是： 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的Cookie。 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。 2.CSRF TOKEN用户打开页面时，服务器给该用户生成一个Token，并保存在Session中，页面加载时将Token插入&lt;a/&gt;&lt;form/&gt;，如 1&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt; 服务器对Token进行验证 但分布式网站中，使用Session存储CSRF Token还需要Redis等进行。在读取和验证CSRF Token时会可能引起较大的性能问题， 可采用Encrypted Token Pattern方式的计算结果代替随机字符串，这样可以避免读取Token Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。来自 https://juejin.im/post/5bc009996fb9a05d0a055192 3.Samesite Cookie属性在Set-Cookie中加入属性Samesite，如 1Set-Cookie: foo=1; Samesite=Strict 表明在任何情况下第三方网站发送请求时都不携带该Cookie 但目前兼容性较差，且不支持子域","link":"/web/CSRF/"},{"title":"Dijkstra&#39;s algorithm","text":"适用于单源点最短路径，通常不能计算负权。时间复杂度O(n^2)。 思想定义两个集合P、Q，表示已求出和未求出最短路径的顶点集；从源点s出发，找到距离最近的点a直接放入P，显然sa就是该点到源点的最短路径；遍历集合Q中的点b，通过点s中转缩短ab，即判断as+sb是否小于ab（此过程名为“松弛”），在Q中找到距离源点第二近的点，此时这个点已经进行过“松弛”，故该点到源点的距离也是最短，然后重复以上过程，即可得到源点到其它所有点的最短路径。 注意若存在点权，应特别注意源点s。因为在第一部中直接将s添加到P，松弛过程中可能不会再考虑s的点权 代码1234567891011121314151617181920212223// 默认源点为s，图为efor (int i = 1; i &lt;= n; i++) { dis[i] = e[s][i];}p[s] = true;for (int i = 1; i &lt;= n; i++) { min = INF; for (int j = 1; j &lt;= n; j++) { if (!p[j] &amp;&amp; dis[j] &lt; min) { min = dis[j]; u = j; } } p[u] = true; for (int v = 1; v &lt;= n; v++) { if (!p[v] &amp;&amp; e[u][v] != INF) { if (dis[v] &gt; dis[u] + e[u][v]) { dis[v] = dis[u] + e[u][v]; } } }} 参考链接https://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html","link":"/algorithm/Dijkstra-s-algorithm/"},{"title":"Floyd-Warshall algorithm","text":"适用于多源最短路径，也被用于计算有有向图的传递闭包，可以正确处理有向图和负权，时间复杂度O(n^3)、空间复杂度O(n^2)。 思想在两个点AB之找到第三个点C，使 AC + CB &lt; AB 代码1234567for (int i = 0; i &lt; size; i++) { for (int j = 0; j &lt; size; j++) { for (int k = 0; k &lt; size; k++) { path[i][j] = min(path[i][j], path[i][k] + path[k][j]); } }}","link":"/algorithm/Floyd-Warshall-algorithm/"},{"title":"Hello World","text":"This is a test page.","link":"/unknown/Hello-World/"},{"title":"Manacher&#39;s algorithm","text":"求字符串的最长回文子串，线性时间复杂度。 传统思路为遍历每个字符，以该字符为中心向两边查找，时间复杂度为O(n^2)，Manachar算法充分利用回文的特点（对称性），减少对回文中心右侧的重复判断，可提升时间复杂度为O(n)。 步骤预处理由于回文分为偶回文和奇回文，为处理简便，将其全部转换为奇回文。e.g. abbc 转换为 ^a#b#b#c$ 定义数组int p[i]，表示以i为中心的最长回文半径e.g. 维护回文中心和回文右边界在此基础上对字符串进行遍历，若字符在右边界内，则可以利用对称性加快查找。 此时应注意，对称位置上的最长回文半径长度可能超过当前字符到边界的距离，所以p[i]应为min(p[mirror_i], mx - i)。 若当前字符已经在边界外，可暂时将p[i]赋为1。 123456if (i &lt; boundary) { p[i] = min(p[mirror_i], mx - i);}else { p[i] = 1;} 更新p[i]以i为中心向两边扩展，更新p 123while (str[i - p[i]] == str[i + p[i]]) { p[i]++;} 代码123456789101112131415161718192021222324252627282930313233string longestPalindrome(string s) { // makes all palindromes odd by inserting # string converted = \"^#\"; for (int i = 0; i &lt; s.length(); i++) { converted += s[i]; converted += \"#\"; } converted += \"$\"; int mcenter = 0, mlength = 0; int center = 0, boundary = 0; int *p = new int[converted.length()]; for (int i = 1; i &lt; converted.length() - 1; i++) { // update by the mirror data if (i &lt; boundary) p[i] = min(p[2 * center - i], boundary - i); else p[i] = 1; // then extend using naive method while (converted[i - p[i]] == converted[i + p[i]]) p[i]++; // update the palindrome cneter if (i + p[i] &gt; boundary) { center = i; boundary = i + p[i]; } // maintain the max center and the max length if (p[i] - 1 &gt; mlength) { mcenter = i; mlength = p[i] - 1; } } return s.substr((mcenter - mlength) / 2, mlength);} 参考链接https://ethsonliu.com/2018/04/manacher.html","link":"/algorithm/Manacher-s-algorithm/"},{"title":"Serializable","text":"序列化Java 中使用 Serializable 接口进行序列化。Serializable 只是语义接口，无实际方法 SerialVersionUIDJava 反序列化时通过判断字节流和相应实体类的 sesrialVersionUID 验证版本是否一致，一致时才能进行反序列化，否则抛出 InvalidCastException 显式定义SerialVersionUID 的两种显式生成方式： 12345// 默认 private static final long serialVersionUID = 1L; // 根据类名、接口名、成员方法、属性生成的 64 位哈希 private static final long serialVersionUID = xxxxL; 隐式定义当一个类实现 Serializable 接口但没有定义 serialVersionUID 时，Java 序列化机制会根据编译的 Class 自动生成一个 serialVersionUID，此时如文件中没有发生变化，则 serialVersionUID 也不会发生变化 阿里巴巴 Java 开发手册中对 serialVersionUID 的规定 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 静态变量Java 在进行序列化时只保存对象的状态，不会保存静态变量，但是 serialVersionUID 会被写入到序列化文件中 12345678910111213141516171819202122232425// ObjectStreamClass.java private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException { if (desc == null) { this.writeNull(); } else { int handle; if (!unshared &amp;&amp; (handle = this.handles.lookup(desc)) != -1) { this.writeHandle(handle); } else if (desc.isProxy()) { this.writeProxyDesc(desc, unshared); } else { this.writeNonProxyDesc(desc, unshared); } } } void writeNonProxy(ObjectOutputStream out) throws IOException { out.writeUTF(this.name); out.writeLong(this.getSerialVersionUID()); byte flags = 0; int i; // ... } transient 关键字Java 对象中使用 Serializable 接口进行序列化，类中不需要进行序列化的字段可以使用 trainsient 修饰","link":"/java/Serializable/"},{"title":"Some tags in maven","text":"Maven标签&lt;scope/&gt;的作用compile默认值，即项目的整个编译、测试、运行阶段 provide只作用于编译阶段、测试阶段，运行时使用容器或JDK中的jar包，例如，当使用Java EE构建一个web应用时，你会设置对Servlet API和相关的Java EE APIs的依赖范围为provided，因为web容器提供了运行时的依赖。 runtime不作用在编译时，但会作用在运行和测试时 test表明使用此依赖范围的依赖，只在编译测试代码和运行测试的时候需要，应用的正常运行不需要此类依赖。 import只可在&lt;dependcyManagent/&gt;中使用，表示从其它的pom中导入dependency的配置 This scope is only supported on a dependency of type pom in the &lt;dependencyManagement/&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s &lt;dependencyManagement/&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.https://maven.apache.org Maven标签&lt;dependencies/&gt;和&lt;dependencyManagement/&gt;的区别Maven使用&lt;dependencyManagement/&gt;提供管理依赖版本的方式，通常用于pom顶层。使用&lt;dependencyManagement/&gt; 元素能让子项目中引用一个依赖而不用显式的列出版本号。 Maven 会向上找到一个拥有&lt;dependencyManagement/&gt; 元素的项目配置版本;&lt;dependencyManagement/&gt;里只声明依赖，但需要在子项目中进行引入。 阿里巴巴 Java 开发手册中对 &lt;dependencies/&gt; 的规定 【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在 语句块中。 说明：里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的 里的依赖都会自动引入，并默认被所有的子项目继承。","link":"/java/Some-tags-in-maven/"}],"tags":[{"name":"web","slug":"web","link":"/tags/web/"},{"name":"csrf","slug":"csrf","link":"/tags/csrf/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"dijkstra","slug":"dijkstra","link":"/tags/dijkstra/"},{"name":"shortest path","slug":"shortest-path","link":"/tags/shortest-path/"},{"name":"longest palindromic substring","slug":"longest-palindromic-substring","link":"/tags/longest-palindromic-substring/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"maven","slug":"maven","link":"/tags/maven/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"java","slug":"java","link":"/categories/java/"}]}