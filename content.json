{"pages":[{"title":"About Me","text":"在校学生~ 联系方式 i@yeli.io 1051210147 学习方向 云计算/Java Web","link":"/about/index.html"}],"posts":[{"title":"1007 Maximum Subsequence Sum","text":"题目内容Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space. Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input:1210-10 1 2 3 4 -5 -23 3 7 -21 Sample Output:110 1 4 题目大意求给出序列的最大子序列和。若结果不唯一，输出最前面的；若全为负值，输出0和整个范围； 解题思路法一 朴素算法直接用二重循环判断子序列的起始和结束位置，计算子序列和是否为最大；对子序列和计算的过程进行优化，使用 「前j个数的和 - 前i个数的和」 表示 「第i+1位到第j位的和」。 算法复杂度 O(N^2)。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e4 + 1;int main() { int n; scanf(\"%d\", &amp;n); int seq[MAXN], acc[MAXN] = {0}; bool allnegative = true; for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;seq[i]); if (seq[i] &gt;= 0) allnegative = false; acc[i] = acc[i - 1] + seq[i]; } if (allnegative) { printf(\"0 %d %d\", seq[1], seq[n]); return 0; } int maxv = 0, start = 0, end = 0; for (int i = 1; i &lt;= n; i++) { for (int j = i; j &lt;= n; j++) { if (acc[j] - acc[i - 1] &gt; maxv) { maxv = acc[j] - acc[i - 1]; start = i; end = j; } } } printf(\"%d %d %d\", maxv, seq[start], seq[end]); return 0;} 法二 动态规划由于最大的连续子序列的位置可能在序列的任何位置，「前i项最大子序列和」和 「前i-1项最大子序列和」是没有直接关系的。所以这里将问题改为 「先求以第i项为结尾的最大子序列和（从哪项开始没有限制），再取所有结果中的最大值」。 容易看出，求以第i项为结尾的最大子序列 可以根据第i-1项求出：如果第i-1项结果为负，那么以第i项结果必然等于序列第i项的值（相当于去掉 负数+a 中的负数后，结果比原来大）；否则等于前i-1项结果加序列第i项（相当于 非负数+a, 结果也会比a大）。 这样就可以得出递推关系： 1以第i项为结尾的最大子序列和 = max(以第i-1项为结尾的最大子序列和 + 序列第i项, 序列第i项) 初始值「以第0项为结尾的最大子序列和」自然是等于0的。此时，已经可以根据初始值和递推关系求出任意一项。再求出所有结果中最大的一项，即题目中要求的最大子序列和。 时间复杂度 O(N)。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e4 + 1;int main() { int n; scanf(\"%d\", &amp;n); int seq[MAXN]; bool allnegative = true; for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;seq[i]); if (seq[i] &gt;= 0) allnegative = false; } if (allnegative) { printf(\"0 %d %d\", seq[1], seq[n]); return 0; } int sum[MAXN] = {0}; int maxv = 0, start = 0, end = 0, t = 0; for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] &lt; 0 ? seq[i] : sum[i - 1] + seq[i]; if (sum[i - 1] &lt;= 0) t = i; if (sum[i] &gt; maxv) { maxv = sum[i]; start = t; end = i; } } printf(\"%d %d %d\", maxv, seq[start], seq[end]); return 0;} 题目链接1007","link":"/algorithm/1007-Maximum-Subsequence-Sum/"},{"title":"1010 Radix","text":"题目内容Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification:Each input file contains one test case. Each case occupies a line which contains 4 positive integers: 1N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output Specification:For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix. Sample Input 1:16 110 1 10 Sample Output 1:12 Sample Input 2:11 ab 1 2 Sample Output 2:1Impossible 题目大意给出一个n进制的数，问另一个数是几进制时可以和它相等，如果不能相等，输出 impossible。 解题思路令已知进制的数为n1，未知的为n2，循环判断n2在不同进制是否能和n1相等。 应注意的点： 输入字符范围是0-z不代表最高是36进制，正确的进制范围应该是n2中最大的数字+1 到 n2本身； 使用二分查找节省时间； n2的最大值是zzzzzzzzzz，按照36进制转换成10进制是3656158440062975，已经超过long，因此所有进制和结果的类型都至少为long long； 此时，使用二分查找中间值计算出的10进制数已经超过long long的范围，判断二分的条件时应该附加溢出判断 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int toInt(char ch) { return isdigit(ch) ? ch - 48 : ch - 87;}long long toDecimal(string num, long long radix) { long long res = 0; for (int i = 0; i &lt; num.length(); i++) { int n = toInt(num[i]); res += n * powl(radix, num.length() - i - 1); } return res;}int main() { string n1, n2; int tag, radix; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix; if (tag == 2) { string t = n1; n1 = n2; n2 = t; } long long target = toDecimal(n1, radix); long long l = toInt(*max_element(n2.begin(), n2.end())) + 1, r = max(l, target); while (l &lt;= r) { long long mid = l + (r - l) / 2, test = toDecimal(n2, mid); if (test == target) { cout &lt;&lt; mid; return 0; } else if (test &gt; target || test &lt; 0) { r = mid - 1; } else { l = mid + 1; } } cout &lt;&lt; \"Impossible\"; return 0;} 小结解题时正数判断溢出可以直接用小于0。 各种翻车，几乎摸清了20个测试点的作用。。。第一遍没有想到进制超过36，后改用二分，没有注意到转换出的值超过long long，最后左边界忘记加1。 参考链接柳婼 の blog","link":"/algorithm/1010-Radix/"},{"title":"CSRF","text":"介绍CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 完整流程 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会… a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 CSRF攻击是以用户身份发送恶意请求（到受信网站），用于发送邮件、购买商品、转账等。 例子Get请求1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; Post请求123456&lt;form action=\"http://www.mybank.com/Transfer\" method=POST&gt; &lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /&gt; &lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /&gt; &lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 思想在Csrf攻击中Get请求比Post请求更容易，应严格遵守HTTP规范，使用Post或Put更新请求资源。 CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的 防御可从服务器端和客户端两方面进行，在服务器端防御效果更好 1.Cookie Hashing（双重Cookie认证）12345678910&lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 由于网站无法获取第三方Cookie，因此这个方案可以杜绝大部分Csrf攻击。 但任何跨域请求都会导致前端无法获取Cookie中的字段（包括子域名之间），于是： 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的Cookie。 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。 2.CSRF TOKEN用户打开页面时，服务器给该用户生成一个Token，并保存在Session中，页面加载时将Token插入&lt;a/&gt;&lt;form/&gt;，如 1&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt; 服务器对Token进行验证 但分布式网站中，使用Session存储CSRF Token还需要Redis等进行。在读取和验证CSRF Token时会可能引起较大的性能问题， 可采用Encrypted Token Pattern方式的计算结果代替随机字符串，这样可以避免读取Token Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。来自 https://juejin.im/post/5bc009996fb9a05d0a055192 3.Samesite Cookie属性在Set-Cookie中加入属性Samesite，如 1Set-Cookie: foo=1; Samesite=Strict 表明在任何情况下第三方网站发送请求时都不携带该Cookie 但目前兼容性较差，且不支持子域","link":"/web/CSRF/"},{"title":"Dijkstra&#39;s algorithm","text":"If 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself “Dijkstra would not have liked this.”, well, that would be enough immortality for me. — E.W.Dijkstra如果十年以后，你以快而脏的方式做什么事的时候，能想象我在你的肩后看着，然后对自己说：「Dijkstra 不会希望这样的。」那么对我来说，这就和永生一样了。 适用于单源点最短路径，通常不能计算负权。时间复杂度O(n^2)。 思想定义两个集合P、Q，表示已求出和未求出最短路径的顶点集；从源点s出发，找到距离最近的点a直接放入P，显然s-&gt;a就是该点到源点的最短路径；遍历集合Q中的点，将其命名为b，通过a-&gt;s-&gt;b缩短ab的距离，即判断as+sb是否小于ab（此过程名为“松弛”），在Q中找到距离源点第二近的点，此时这个点已经进行过“松弛”，故该点到源点的距离也是最短，然后重复以上过程，即可得到源点到其它所有点的最短路径。 注意若存在点权，应特别注意源点s。因为在第一步中直接将s添加到P，松弛过程中不会再计算s的点权 代码12345678910111213141516171819202122232425// 默认源点为s，图为efor (int i = 1; i &lt;= n; i++) { dis[i] = e[s][i];}p[s] = true;for (int i = 1; i &lt;= n; i++) { min = INF; for (int j = 1; j &lt;= n; j++) { if (!p[j] &amp;&amp; dis[j] &lt; min) { min = dis[j]; u = j; } } p[u] = true; if (u == -1) break; for (int v = 1; v &lt;= n; v++) { if (!p[v] &amp;&amp; e[u][v] != INF) { if (dis[v] &gt; dis[u] + e[u][v]) { dis[v] = dis[u] + e[u][v]; } } }} 参考链接https://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html","link":"/algorithm/Dijkstra-s-algorithm/"},{"title":"Floyd-Warshall algorithm","text":"适用于多源最短路径，也被用于计算有有向图的传递闭包，可以正确处理有向图和负权，时间复杂度O(n^3)、空间复杂度O(n^2)。 思想在两个点AB之找到第三个点C，使 AC + CB &lt; AB 代码1234567for (int i = 0; i &lt; size; i++) { for (int j = 0; j &lt; size; j++) { for (int k = 0; k &lt; size; k++) { path[i][j] = min(path[i][j], path[i][k] + path[k][j]); } }}","link":"/algorithm/Floyd-Warshall-algorithm/"},{"title":"Generics in Java","text":"以下注释内容无法通过编译 关于协变 （Covariant） Java 中数组协变的，泛型不是。 Java 1.5 开始子类覆盖父类的方法时可以返回具体的类型。 123456789101112131415class Food {}class Fruit extends Food {}class Apple extends Fruit {}@Testpublic void covarianceTest() { // 数组支持协变 Fruit[] fruits = new Apple[]{ new Apple() }; // 编译错误，泛型不支持协变 // ArrayList&lt;Fruit&gt; array = new ArrayList&lt;Apple&gt;(); // 可以使用上界限定通配符 List&lt;? extends Fruit&gt; list = new ArrayList&lt;Apple&gt;();} 上界限定通配符（Upper Bounds Wildcards）只能传入该类型及其子类的对象 123456789private static void extendTest(List&lt;? extends Fruit&gt; fruits) { // 此时容器不知道 List 的具体类型，（不能确定传入的是Fruit或Apple），因此为避免类型转换出错，也无法再向容器中添加任何类型 // List&lt;?&gt; 同理 // fruits.add(new Fruit()); // fruits.add(new Apple()); // fruits.add(new Food()); fruits.add(null);} 下界限定通配符（Lower Bounds Wildcards）只能传入该类型及其父类的对象 1234567private static void superTest(List&lt;? super Fruit&gt; fruits) { // 此时容器已经可以确实传入的类型一定是Fruit或它的父类 // 因此可以向容器中添加Fruit和它的子类对象，不会发生类型转换错误 fruits.add(new Apple()); fruits.add(new Fruit()); // fruits.add(new Food());} 限定符测试12345678910@Testpublic void genericTest() { // 只能传入Fruit和它的父类 superTest(new ArrayList&lt;Food&gt;()); // superTest(new ArrayList&lt;Apple&gt;()); // 只能传入Fruit和它的子类 extendTest(new ArrayList&lt;Apple&gt;()); // extendTest(new ArrayList&lt;Food&gt;());} 递归类型参数（Recursive Type Parameter）简化的栗子： 12345678910abstract class ClassA&lt;T extends ClassA&lt;T&gt;&gt; { abstract T m();}class ClassB extends ClassA&lt;ClassB&gt; { @Override public ClassB m() { return new ClassB(); }} Effective Java中的建造者模式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; { EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // Subclasses must override this method to return \"this\" protected abstract T self(); } Pizza(Builder&lt;?&gt; builder) { toppings = builder.toppings.clone(); // See Item 50 }}// Subclass with hierarchical builder (Page 15)public class NyPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; { private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Override public NyPizza build() { return new NyPizza(this); } @Override protected Builder self() { return this; } } private NyPizza(Builder builder) { super(builder); size = builder.size; }} 使用递归的类型参数和抽象的self方法一样，允许在子类中适当地进行方法链接，不需要转换类型。 &lt;T extend builder&lt;T&gt;&gt;和&lt;T extend builder&gt;这两者的区别： 递归的 T extends Builder是指，T 只能是 Builder 的子类型。因为 Builder是个泛型类，在描述「某个具体的 Builder 类型」 时，就必须带上类型参数。对于这里来说，就是 T。T extends Builder 严格来说是错误的。当然，对于 Java 来讲，你不带 T 也是完全没问题的，编译器也不会给你警告，最多让 IDEA 提示一句「Raw use of parameterized class」，毕竟 Java 的泛型编译后都会被擦除，运行是时候都是一样的。不过，带上泛型更有利于编译器检查，也更有利于写出类型安全的代码。 Pizza的构造器参数为Builder&lt;?&gt; builder，这里泛型定义为&lt;? extend Builder&gt;不应该更好吗？ 因为 Builder 声明为 T extends Builder 就保证了 T 一定是 Builder 的子类型， 这里就没有必要再重复限制一次了。 父类的Builder使用递归泛型及使用self()是为了 父类方法返回子类 这种功能吗？ Self 类型是在接口中用描述实现接口的具体类型的特殊类型标识，用来安全地从父类型向子类型转换对象。一般来说，把父类型的对象转换为子类型的对象，都要用强制类型转换。这样做很不优雅，也不「type safe」。不过利用递归的类型参数，可以避免强制类型转换，这也是递归类型参数的重要用法。 参考链接知乎：Java泛型递归模式的意义","link":"/java/Generics-in-Java/"},{"title":"Hello World","text":"This is a test page.","link":"/unknown/Hello-World/"},{"title":"Manacher&#39;s algorithm","text":"求字符串的最长回文子串，线性时间复杂度。 传统思路为遍历每个字符，以该字符为中心向两边查找，时间复杂度为O(n^2)，Manachar算法充分利用回文的特点（对称性），减少对回文中心右侧的重复判断，可提升时间复杂度为O(n)。 步骤预处理由于回文分为偶回文和奇回文，为处理简便，将其全部转换为奇回文。e.g. abbc 转换为 ^a#b#b#c$ 定义数组int p[i]，表示以i为中心的最长回文半径e.g. 维护回文中心和回文右边界在此基础上对字符串进行遍历，若字符在右边界内，则可以利用对称性加快查找。 此时应注意，对称位置上的最长回文半径长度可能超过当前字符到边界的距离，所以p[i]应为min(p[mirror_i], mx - i)。 若当前字符已经在边界外，可暂时将p[i]赋为1。 123456if (i &lt; boundary) { p[i] = min(p[mirror_i], mx - i);}else { p[i] = 1;} 更新p[i]以i为中心向两边扩展，更新p 123while (str[i - p[i]] == str[i + p[i]]) { p[i]++;} 代码123456789101112131415161718192021222324252627282930313233string longestPalindrome(string s) { // makes all palindromes odd by inserting # string converted = \"^#\"; for (int i = 0; i &lt; s.length(); i++) { converted += s[i]; converted += \"#\"; } converted += \"$\"; int mcenter = 0, mlength = 0; int center = 0, boundary = 0; int *p = new int[converted.length()]; for (int i = 1; i &lt; converted.length() - 1; i++) { // update by the mirror data if (i &lt; boundary) p[i] = min(p[2 * center - i], boundary - i); else p[i] = 1; // then extend using naive method while (converted[i - p[i]] == converted[i + p[i]]) p[i]++; // update the palindrome cneter if (i + p[i] &gt; boundary) { center = i; boundary = i + p[i]; } // maintain the max center and the max length if (p[i] - 1 &gt; mlength) { mcenter = i; mlength = p[i] - 1; } } return s.substr((mcenter - mlength) / 2, mlength);} 参考链接https://ethsonliu.com/2018/04/manacher.html","link":"/algorithm/Manacher-s-algorithm/"},{"title":"Serializable","text":"序列化Java 中使用 Serializable 接口进行序列化。Serializable 只是语义接口，无实际方法 SerialVersionUIDJava 反序列化时通过判断字节流和相应实体类的 sesrialVersionUID 验证版本是否一致，一致时才能进行反序列化，否则抛出 InvalidCastException 显式定义SerialVersionUID 的两种显式生成方式： 12345// 默认 private static final long serialVersionUID = 1L; // 根据类名、接口名、成员方法、属性生成的 64 位哈希 private static final long serialVersionUID = xxxxL; 隐式定义当一个类实现 Serializable 接口但没有定义 serialVersionUID 时，Java 序列化机制会根据编译的 Class 自动生成一个 serialVersionUID，此时如文件中没有发生变化，则 serialVersionUID 也不会发生变化 阿里巴巴 Java 开发手册中对 serialVersionUID 的规定 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 静态变量Java 在进行序列化时只保存对象的状态，不会保存静态变量，但是 serialVersionUID 会被写入到序列化文件中 12345678910111213141516171819202122232425// ObjectStreamClass.java private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException { if (desc == null) { this.writeNull(); } else { int handle; if (!unshared &amp;&amp; (handle = this.handles.lookup(desc)) != -1) { this.writeHandle(handle); } else if (desc.isProxy()) { this.writeProxyDesc(desc, unshared); } else { this.writeNonProxyDesc(desc, unshared); } } } void writeNonProxy(ObjectOutputStream out) throws IOException { out.writeUTF(this.name); out.writeLong(this.getSerialVersionUID()); byte flags = 0; int i; // ... } transient 关键字Java 对象中使用 Serializable 接口进行序列化，类中不需要进行序列化的字段可以使用 trainsient 修饰","link":"/java/Serializable/"},{"title":"Some tags in maven","text":"Maven标签&lt;scope/&gt;的作用compile默认值，即项目的整个编译、测试、运行阶段 provide只作用于编译阶段、测试阶段，运行时使用容器或JDK中的jar包，例如，当使用Java EE构建一个web应用时，你会设置对Servlet API和相关的Java EE APIs的依赖范围为provided，因为web容器提供了运行时的依赖。 runtime不作用在编译时，但会作用在运行和测试时 test表明使用此依赖范围的依赖，只在编译测试代码和运行测试的时候需要，应用的正常运行不需要此类依赖。 import只可在&lt;dependcyManagent/&gt;中使用，表示从其它的pom中导入dependency的配置 This scope is only supported on a dependency of type pom in the &lt;dependencyManagement/&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s &lt;dependencyManagement/&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.https://maven.apache.org Maven标签&lt;dependencies/&gt;和&lt;dependencyManagement/&gt;的区别Maven使用&lt;dependencyManagement/&gt;提供管理依赖版本的方式，通常用于pom顶层。使用&lt;dependencyManagement/&gt; 元素能让子项目中引用一个依赖而不用显式的列出版本号。 Maven 会向上找到一个拥有&lt;dependencyManagement/&gt; 元素的项目配置版本;&lt;dependencyManagement/&gt;里只声明依赖，但需要在子项目中进行引入。 阿里巴巴 Java 开发手册中对 &lt;dependencies/&gt; 的规定 【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在 语句块中。 说明：里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的 里的依赖都会自动引入，并默认被所有的子项目继承。","link":"/java/Some-tags-in-maven/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"maximum subsequence sum","slug":"maximum-subsequence-sum","link":"/tags/maximum-subsequence-sum/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"csrf","slug":"csrf","link":"/tags/csrf/"},{"name":"shortest path","slug":"shortest-path","link":"/tags/shortest-path/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"generic","slug":"generic","link":"/tags/generic/"},{"name":"longest palindromic substring","slug":"longest-palindromic-substring","link":"/tags/longest-palindromic-substring/"},{"name":"maven","slug":"maven","link":"/tags/maven/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"java","slug":"java","link":"/categories/java/"}]}